# üìñ The Ontology Bible (vision spec)

> This document describes **the intended end-state** (not necessarily what you have today). It‚Äôs the single source of truth for authors and implementers.

## 0) Purpose & mental model

We model foods via three building blocks:

* **T (Taxon)**: biological source (e.g., `tx:plantae:oleaceae:olea:europaea`)
* **P (Part)**: anatomical or process-derived component (e.g., `part:fillet`, `part:butter`)
* **TPT (Transformed Product)**: a concrete product of a (T, P) undergoing transforms (e.g., ‚ÄúCold-smoked salmon‚Äù)

Authoring new foods = choosing a T, choosing/creating the right P (product-anchored), then describing its **identity path** (sequence of `tf:*` transforms with identity-bearing params).

Everything downstream (search facets, families, cuisine hints, safety flags) is computed from those primitives.

---

## 1) IDs & casing

* **Taxa (`tx:*`)**: `tx:segment:segment[: ...]`. A **full ID has no trailing colon**; a **prefix ends with `:`**.
* **Parts (`part:*`)**: anatomical parts use `part:{specific}` with `category` field; hierarchical parts use `part:{parent}:{child}` only when child is truly a component of parent.

  * `id`: lower_snake
  * `kind`: `"plant" | "animal" | "fungus" | "derived"`
  * `category` (required): clarifies role and enables filtering (e.g., `organ`, `cut`, `egg`, `grain`, `fruit`, `dairy`, `oil`, `muscle`, `fat`, `bone`)
  * `parent_id`: explicit; hierarchy must be acyclic.
* **Transforms (`tf:*`)**: `tf:[a-z0-9_]+`. One ID ‚Üí one schema, one `order`, stable params.
* **Names**: `display_name` Title Case; synonyms are plain strings (no qualifiers like `(salted)`).

---

## 2) Files (what they are, how to use them)

### Core definitions

* **`taxa/*.jsonl`**: taxon backbone (biological graph). Source of truth for `tx:*`.
* **`parts.core.json`**: biological/anatomical + primary process parts (e.g., milk, cream, muscle, fruit).

  * Required fields: `id`, `name`, `kind`
  * Optional: `category`, `parent_id`, `notes`
  * Must NOT contain `kind:"derived"`
* **`parts.derived.jsonl`**: product parts (butter, yogurt, hard cheese, lard, ghee, oil:virgin/refined, fillet, fruit:peel:*).

  * Same schema as core parts
  * MUST set `kind:"derived"` and `parent_id` pointing into the merged universe
* **`build/parts.registry.json`**: merged registry (generated by Stage 0/A)

  * Single authoritative parts table used by all later stages
* **`transforms.json`**: registry for unit operations (`tf:*`) with:

  * `id`, `name`, `identity:boolean`, `order:int`, and `params[]`
  * Each param: `{ key, kind, enum?, unit?, identity_param? }`
* **`families.json`**: product family definitions used for grouping/labeling.

  * Keys ‚Üí `{ id, display_name, identity_transforms:[], identity_params?:[], naming, defaults, param_buckets }`
* **`family_allowlist.jsonl`**: applicability rules specifying which (taxon, part) combinations each family can be applied to.

  * Each line: `{ "family": "FAMILY_ID", "taxon_prefix": "tx:...", "parts": ["part:..."] }`
* **`param_buckets.json`** (optional): reusable numeric/enum bucket sets referenced by families.

### Rules & UX metadata

* **Family display names**: Defined in `families.json` with `display_name` field.

### Family System Architecture

The family system uses two complementary files:

* **`families.json`**: Contains family metadata (display names, transforms, naming rules, defaults, param buckets)
* **`family_allowlist.jsonl`**: Contains applicability rules (which taxon+part combinations each family can be applied to)

This separation allows:
- **Clean PR diffs**: Changes to applicability rules don't clutter family metadata
- **Focused maintenance**: Family definitions vs applicability rules are separate concerns  
- **Scalability**: Allowlist can grow without bloating the main families file
- **Precision control**: Prevents nonsensical TPTs (e.g., cultured dairy from fish muscle)
* **`rules/diet_safety_rules.jsonl`**: emitted flags when conditions match.

  * Grammar:

    * `{"when":{"has_transform":"tf:smoke"}, "emit":"smoked","flag_type":"safety"}`
    * `{"when":{"param":"tf:cure.nitrite_ppm","op":"gt","value":0}, ...}`
    * Supports `allOf`/`noneOf` as logical combinators.
* **`rules/cuisine_map.jsonl`**: attaches cuisine tags from `{taxon_prefix, parts}` (optionally transforms later).
* **`rules/name_overrides.jsonl`**: tidy display names for `(taxon_id, part_id)` pairs.
* **`rules/taxon_part_synonyms.jsonl`**: synonyms per `(taxon_id, part_id)`; no transform/marketing terms.

### Applicability

* **`parts_applicability.jsonl`**: which parts may apply to which taxa.

  * Encourage **prefix rules** with explicit `exclude` arrays.
* **`implied_parts.jsonl`** (optional): parts to auto-attach; must be subset of applicability.
* **Family expansion**: Families are expanded to (taxon, part) pairs based on `identity_transforms` in `families.json` and applicability rules in `family_allowlist.jsonl`.

### Product prototyping

* **`promoted_parts.jsonl`**: **recipes** for existing `part_id`s (no new IDs).

  * `proto_path` is a minimal transform chain that often produces that part.
  * This is **not** a replacement for authoring real TPTs; it seeds defaults.
  * No longer *defines* IDs; only carries recipes keyed by existing part IDs from the merged registry.

### Authoring T/PT/TPT

* **`taxon_part_nodes`** (generated): materialized `(T, P)` combos (TP). May be backfilled from TPTs.
* **`derived_foods.jsonl`** or `tpts.jsonl`: actual product instances (TPTs):

  * `{ id, taxon_id, part_id, path[], identity[], family?, name, synonyms[] }`
  * `identity[]` is the subset of `path[]` used to compute `identity_hash`.

### Category Ontology

* **`categories.json`**: authoritative registry of all part categories with metadata.

  * Required fields: `id`, `name`, `description`, `kind`
  * `id`: category identifier used in parts (e.g., `"fruit"`, `"cut"`, `"dairy"`)
  * `name`: display name for UI (e.g., `"Fruit"`, `"Cut"`, `"Dairy"`)
  * `description`: human-readable description of the category
  * `kind`: biological kind this category applies to (`"plant"`, `"animal"`, `"fungus"`, `"derived"`)
  * **Single source of truth** for all category validation and UI display
  * **Self-validating** - validators read from this file, preventing data drift

---

## 3) Product-part anchoring (the "why" and "how")

**Why**: users think in products ("butter", "yogurt", "hard cheese"), not substrates ("cream", "milk"). Anchoring TPTs to product parts makes filtering, grouping, synonyms, and identity dedupe natural.

**How**:

* Put derived product parts in `parts.derived.jsonl` with `kind:"derived"` and correct `parent_id` ‚Üí substrate.
* Build `part_ancestors` in Stage F (transitive closure).
* TPTs set `part_id` = product (e.g., `part:butter`), not the substrate.
* Queries like "is dairy?" become: `EXISTS (SELECT 1 FROM part_ancestors WHERE descendant_id=tpt.part_id AND ancestor_id='part:milk')`.

**Examples**:

```
part:butter (derived) ‚Üí part:cream ‚Üí part:milk
part:yogurt (derived) ‚Üí part:fermented_milk ‚Üí part:milk
part:cheese:hard (derived) ‚Üí part:cheese ‚Üí part:milk
```

---

## 4) Product-Part Anchoring Architecture

**Core parts** (`parts.core.json`): Biological/anatomical + primary process parts (e.g., milk, cream, muscle, fruit).
**Derived parts** (`parts.derived.jsonl`): Product parts (butter, yogurt, hard cheese, lard, ghee, oil:virgin/refined, fillet, fruit:peel:*).
**Registry merge**: Stage 0/A merges these into `build/parts.registry.json` (the single authoritative parts table used by all later stages).
**TPT anchoring**: Use product parts for derived foods (e.g., `part:butter`). Substrate queries use `part_ancestors` built from the merged registry.

### Files & Schemas

`parts.core.json` holds primary/anatomical parts. Must NOT contain `kind:"derived"`.
`parts.derived.jsonl` holds product parts. MUST use the same schema as core (id, name, kind, category, parent_id, notes). MUST set `kind:"derived"` and `parent_id` pointing into the merged universe (usually a core part).
The build step emits `build/parts.registry.json` which downstream stages consume as if it were a single `parts.json`.

### Guardrails (split registry)

1. **Uniqueness**: No duplicate `id` across core + derived.
2. **No orphan parents**: Every `parent_id` must resolve AFTER the union.
3. **No cycles** across the combined hierarchy.
4. **Kind vocabulary**: `plant|animal|fungus|derived|any` (schema-enforced).
5. **Biological ancestry for derived**: every `kind:"derived"` must trace to at least one biological ancestor (`plant|animal|fungus`) via `parent_id` links.
6. **Depth**: hierarchy depth ‚â§ 5 (configurable).
7. **Core purity**: `parts.core.json` must not contain `kind:"derived"`.

### Contributor workflow

- Add/modify anatomical parts in `parts.core.json`.
- Add/modify product parts in `parts.derived.jsonl` (JSONL; one object per line; same schema).
- Do **not** define IDs in `promoted_parts.jsonl` (recipes only).
- Run the build to generate `build/parts.registry.json`; review validation reports.

### Part Ancestry

`part_ancestors` is built from `part_def` loaded from `build/parts.registry.json`.

### Example: adding butter (split)

Add this line to `parts.derived.jsonl`:
`{"id":"part:butter","name":"butter","kind":"derived","category":"dairy","parent_id":"part:cream","notes":"Churned W/O emulsion from cream"}`
Confirm that `part:cream` exists in `parts.core.json` and that the merged registry validates.

### Promoted parts

`promoted_parts.jsonl` no longer *defines* IDs. It only carries **recipes** (e.g., `proto_path`, `byproducts`) keyed by existing part IDs from the merged registry.

---

## 5) Transforms & identity

* **Single source of truth** per `tf:id` (merged duplicates).
* **Stable `order`** provides deterministic identity reasoning.

  * Suggested anchors: `cure(60) ‚Üí smoke(70) ‚Üí cook(75) ‚Üí age(80) ‚Üí dry(90)`
* **Identity-bearing params** are explicitly marked (e.g., `tf:cure.style`, `tf:cure.nitrite_ppm`, `tf:smoke.mode`, `tf:clarify_butter.stage`).
* **Param units**: use canonical keys with units in key names where helpful (`temp_C`, `nitrite_ppm`, `salt_pct`).

---

## 6) Validation (ETL2, Stage F)

**SQLite schema adds**

* `part_ancestors(descendant_id, ancestor_id, depth)` (closure)
* Partial unique index on `(taxon_id, part_id, identity_hash) WHERE identity_hash IS NOT NULL`

**Soft/hard checks (split registry)**

* **Uniqueness**: No duplicate `id` across core + derived.
* **No orphan parents**: Every `parent_id` must resolve AFTER the union.
* **No cycles** across the combined hierarchy.
* **Kind vocabulary**: `plant|animal|fungus|derived|any` (schema-enforced).
* **Category required**: every part must have a `category` field for filtering and organization.
* **Biological ancestry for derived**: every `kind:"derived"` must trace to at least one biological ancestor (`plant|animal|fungus`) via `parent_id` links.
* **Depth**: hierarchy depth ‚â§ 5 (configurable).
* **Core purity**: `parts.core.json` must not contain `kind:"derived"`.
* TPT steps must reference known transforms, with known params.
* Enum values must be valid.

**Flag evaluation**

* The evaluator considers **all occurrences** of a transform when evaluating `when.param`.

---

## 7) Authoring checklist

### Adding a new product family

1. Add family to `families.json` with `id`, `display_name`, `identity_transforms`, `identity_params`, `naming`, `defaults`, and `param_buckets`.
2. Add applicability rules to `family_allowlist.jsonl` specifying which (taxon, part) combinations the family can be applied to.
3. (Optional) Add buckets in `param_buckets.json` and reference them.

### Adding/adjusting parts

1. **Anatomical parts**: Add to `parts.core.json` with `id`, `name`, `kind`, optional `category`, `parent_id`.
2. **Product parts**: Add to `parts.derived.jsonl` with same schema, MUST set `kind:"derived"` and `parent_id` pointing to core part.
3. Ensure ancestry makes sense and is acyclic across the merged registry.
4. If it's a product part, consider a `promoted_parts.jsonl` proto recipe (recipes only, no new IDs).

### Adding transforms or params

1. Add to `transforms.json` with `id`, `name`, `identity`, `order`, `params[]`.
2. If renaming a param, update families, rules, exemplars to match.

### Authoring a TPT (‚Äúproduct instance‚Äù)

* Pick `taxon_id` (exact), `part_id` (product-part).
* Write `path[]` (full process) and `identity[]` (identity-bearing subset).
* Give a human `name` and optional `synonyms[]`.
* Run ETL + validators.

---

## 8) Worked examples (ready to paste)

**Greek yogurt (product anchored by substrate; OK because part is product of milk)**

```json
{
  "id":"tpt:tx:animalia:chordata:mammalia:artiodactyla:bovidae:bos:taurus:part:milk:unknown:greek-yogurt",
  "taxon_id":"tx:animalia:chordata:mammalia:artiodactyla:bovidae:bos:taurus",
  "part_id":"part:milk",
  "family":"DAIRY_YOGURT",
  "path":[{"id":"tf:ferment","params":{"starter":"yogurt_thermo"}},{"id":"tf:strain","params":{"strain_level":6}}],
  "identity":[{"id":"tf:ferment","params":{}},{"id":"tf:strain","params":{}}],
  "name":"Greek Yogurt",
  "synonyms":["strained yogurt"]
}
```

**Ghee (anchored to product part: butter)**

```json
{
  "id":"tpt:tx:animalia:chordata:mammalia:artiodactyla:bovidae:bos:taurus:part:butter:unknown:ghee",
  "taxon_id":"tx:animalia:chordata:mammalia:artiodactyla:bovidae:bos:taurus",
  "part_id":"part:butter",
  "family":"DAIRY_BUTTER",
  "path":[{"id":"tf:clarify_butter","params":{"stage":"ghee"}}],
  "identity":[{"id":"tf:clarify_butter","params":{}}],
  "name":"Ghee",
  "synonyms":["clarified butter"]
}
```

**Example: adding butter (split registry)**

Add this line to `parts.derived.jsonl`:
```json
{"id":"part:butter","name":"butter","kind":"derived","category":"dairy","parent_id":"part:cream","notes":"Churned W/O emulsion from cream"}
```

Confirm that `part:cream` exists in `parts.core.json` and that the merged registry validates.

**American bacon (identity via cure+smoke)**

```json
{
  "id":"tpt:tx:animalia:chordata:mammalia:artiodactyla:suidae:sus:scrofa_domesticus:part:belly:unknown:us-bacon",
  "taxon_id":"tx:animalia:chordata:mammalia:artiodactyla:suidae:sus:scrofa_domesticus",
  "part_id":"part:belly",
  "family":"PORK_CURED_SMOKED",
  "path":[
    {"id":"tf:cure","params":{"style":"dry","nitrite_ppm":120}},
    {"id":"tf:smoke","params":{"mode":"hot","time_h":4,"temp_C":80}}
  ],
  "identity":[
    {"id":"tf:cure","params":{"style":"dry","nitrite_ppm":120}},
    {"id":"tf:smoke","params":{"mode":"hot"}}
  ],
  "name":"American Bacon",
  "synonyms":["streaky bacon (hot-smoked)"]
}
```

**Cold-smoked salmon (product anchored at cut)**

```json
{
  "id":"tpt:tx:animalia:chordata:actinopterygii:salmoniformes:salmo:salar:part:fillet:unknown:cold-smoked-salmon",
  "taxon_id":"tx:animalia:chordata:actinopterygii:salmoniformes:salmo:salar",
  "part_id":"part:fillet",
  "family":"FISH_CURED_SMOKED",
  "path":[
    {"id":"tf:cure","params":{"style":"dry","nitrite_ppm":0}},
    {"id":"tf:smoke","params":{"mode":"cold","temp_C":22,"time_h":12}}
  ],
  "identity":[
    {"id":"tf:cure","params":{"style":"dry","nitrite_ppm":0}},
    {"id":"tf:smoke","params":{"mode":"cold"}}
  ],
  "name":"Cold-smoked Salmon",
  "synonyms":["lox"]
}
```

**Salt cod (bacalhau)**

```json
{
  "id":"tpt:tx:animalia:chordata:actinopterygii:gadiformes:gadus:morrhua:part:fillet:unknown:bacalhau",
  "taxon_id":"tx:animalia:chordata:actinopterygii:gadiformes:gadus:morrhua",
  "part_id":"part:fillet",
  "family":"FISH_SALTED_DRY",
  "path":[
    {"id":"tf:salt","params":{"salt_pct":20,"method":"dry"}},
    {"id":"tf:dry","params":{}}
  ],
  "identity":[
    {"id":"tf:salt","params":{"salt_pct":20}},
    {"id":"tf:dry","params":{}}
  ],
  "name":"Salt Cod (Bacalhau)",
  "synonyms":["bacalhau","bacalao"]
}
```

---

## 9) Conventions & gotchas

* **Do not** encode transforms in synonyms (e.g., ‚Äúsmoked salmon‚Äù)‚Äîthat belongs in TPT identity.
* **Eggs**: use `kind:"animal"` + `category:"egg"`; scope to birds/reptiles via applicability, not via `kind`.
* **Cuts**: are anatomical; use `kind:"animal"` with `category:"cut"` and `parent_id:"part:muscle"`.
* **Caviar**: is a **TPT** (salted roe), not a part. Keep `part:egg:fish:roe` as the part.

### Part Naming Convention

**Anatomical parts** (most common): Use `part:{specific}` with `category` field
- `part:shoulder` with `category: "cut"` (not `part:cut:shoulder`)
- `part:liver` with `category: "organ"` (not `part:organ:liver`)
- `part:fruit` with `category: "fruit"`
- `part:muscle` with `category: "muscle"`

**Hierarchical parts** (true parent-child relationships): Use `part:{parent}:{child}`
- `part:egg:white` (white is a component of egg)
- `part:egg:yolk` (yolk is a component of egg)
- `part:fat:leaf` (leaf fat is a type of fat)

**Why categories matter**: Enable filtering and searching by part type
- "Show all cuts": `WHERE category = "cut"`
- "Show all organs": `WHERE category = "organ"`
- "Show all dairy products": `WHERE category = "dairy"`

### Category Rules

**Category Ontology Requirements**:
- **All parts must have a valid category** from `categories.json`
- **Categories are immutable** - never hardcode category lists in validators
- **Single source of truth** - all category validation reads from `categories.json`
- **Rich metadata** - categories include `id`, `name`, `description`, `kind`

**Category Assignment Rules**:
- **Biological parts** use categories matching their biological function (`fruit`, `muscle`, `organ`)
- **Processed parts** use categories matching their product type (`dairy`, `oil`, `byproduct`)
- **Hierarchical parts** inherit category from parent when appropriate (`part:fat:leaf` ‚Üí `category: "fat"`)
- **Consolidation** - group similar concepts (e.g., `pulp` and `serum` ‚Üí `byproduct`)

**Category Validation**:
- **Schema compliance** - `part.schema.json` references `categories.json`
- **Runtime validation** - validators load categories dynamically
- **UI integration** - categories include display names and descriptions
- **Database integration** - categories are loaded into database for queries

